## 7. Асинхронщина

### 7.1. [Классическая задача про асинхронность](./typical-async_low/typical-async_low.md) (low difficulty).

<details>
<summary>Ответ</summary>

- Сначала выполняется синхронный код.

```sh
1
4
```

- Потом первый таймаут идет считаться в WebAPI;
- Когда он отсчитывается, он заносится в очередь асинхронных задач;
- В очереди пусто поэтому коллбэк вызывается;

```sh
2
```

- Потом второй (вложенный) таймаут идет считаться в WebAPI;
- Когда он отсчитывается, он заносится в очередь асинхронных задач;
- В очереди пусто поэтому коллбэк вызывается;

```sh
3
```

[Статья Джейка Арчибальда на эту тему](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/);

</details>

### 7.2. [Классическая задача про асинхронность](./typical-async_medium/typical-async_medium.md) (medium difficulty).

<details>
<summary>Ответ</summary>

- Сначала выполняется синхронный код.

```sh
1
5
```

- Потом первый таймаут идет считаться в WebAPI;
- Когда он отсчитывается, он заносится в очередь асинхронных задач;
- Потом резолвается промис и первый `then` заносится в очередь микротасок;
- Микротаски имеют приоритет над обычными тасками, поэтому сначала выведется первый `then`;

```sh
3
```

- После этого объявляется второй `then`;
- Он добавляется в очередь микротасок;
- Микротаски имеют приоритет над обычными тасками, поэтому второй `then` вызывается сейчас же;

```sh
4
```

- После этого из очереди обычных асинхронных задач вызывается коллбэк таймаута;

```sh
2
```

[Статья Джейка Арчибальда на эту тему](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/);

</details>

### 7.3. [Классическая задача про асинхронность](./typical-async-task/typical-async-task.md) (dead-inside difficulty).

<details>
<summary>Ответ</summary>

1. Сначала проверяем, что у нас в синхронном потоке: это `console.log(0);` и `console.log(16)` - они выведутся первыми;

```bash
"0"
"16"
```

2. Смотрим на асинхронные операции: два таймаута и два промис-резолва;

3. Таймауты отправляются отсчитывать время, когда отсчитают, занесутся в очередь;

4. В очередь попадают промисы (помни, что **у промисов приоритет больший, чем у обычных коллбэков**);

5. Начинают вызываться `.then`ы промисов по уровням вложенности - первый уровень `then`ов (`console.log(3);`, `console.log(9);`), второй и т.д.;

```bash
"3"
"9"
```

6. В первом `.then` первого промиса бросается ошибка. Из-за это следующие `.then` этого промиса не будут вызваны - будет вызван `.catch` первого промиса;

7. Но `.catch` первого промиса находится на шестом уровне вложенности. Поэтому прежде чем вызовется `.catch` первого промиса, должны вызваться первые пять уровней второго;

```bash
"10"
"11"
"12"
"13"
```

8. Потом вызывается шестой уровень вложенности;

```bash
"8"
"14"
```

9. Ждём пока таймауты отсчитаются;

10. Первым отсчитается таймер на 0 секунд, потом таймер на 1 секунду;

```bash
"2"
"1"
```

</details>

### 7.4. Зачем использовать `requestAnimationFrame` ?

<details>
<summary>Ответ</summary>

- Приостановка анимации, когда вкладка в фоновом режиме или процессор перегружен;
- Браузер выполняет анимацию в удобный для него момент;

[Джейк Арчибальд объясняет то же самое, только лучше](https://youtu.be/cCOL7MC4Pl0?t=749)

</details>

### 7.5. [Промисификация](./promisification/promisification.md).

<details>
<summary>Ответ</summary>

Нужно написать функции, которые возвращают промисы.

[Решение](./promisification/promisification.js);

</details>

### 7.6. [Задача про блокирование потока](./main-thread-blocking/main-thread-blocking.md).

<details>
<summary>Ответ</summary>

1. В JavaScript один поток.
2. Перерисовка страницы выполняется в этом же потоке;
3. Поэтому когда что-то блочит поток, перерисовка не происходит;

[Джейк Арчибальд объясняет то же самое, только лучше](https://youtu.be/cCOL7MC4Pl0?t=534)

</details>

### 7.7. [Как незаметно заблокировать поток ?](./main-thread-ninja-blocking/main-thread-ninja-blocking.md).

<details>
<summary>Ответ</summary>

Бесконечные таймауты не заблокируют поток, потому что это такие же таски, как и перерисовка.

```js
// не заблокирует поток
function endlessTimeout() {
  setTimeout(endlessTimeout, 0);
}
```

---

Бесконечные промисы заблокируют поток, потому что микротаски имеют приоритет над обычными тасками (перерисовкой страницы в том числе).

```js
// заблокирует поток
function endlessPromise() {
  return Promise.resolve().then(endlessPromise);
}
```

[Джейк Арчибальд объясняет то же самое, только лучше (обычные таски и рендеринг)](https://youtu.be/cCOL7MC4Pl0?t=693)

[Джейк Арчибальд объясняет то же самое, только лучше (микротаски и рендеринг)](https://youtu.be/cCOL7MC4Pl0?t=1618)

</details>

### 7.8. [Подождать выполнения всех промисов](./promise-all/promise-all.md).

<details>
<summary>Ответ</summary>

Используй `Promise.all`.

```js
const usersRequest = axios("https://jsonplaceholder.typicode.com/users");
const postsRequest = axios("https://jsonplaceholder.typicode.com/posts");

Promise.all([usersRequest, postsRequest])
  .then((results) => results.map((result) => result.data))
  .then(([usersData, postsData]) => {
    console.log(usersData, postsData);
  });
```

</details>

### 7.9. Какие еще статические методы промисов знаешь ?

<details>
<summary>Ответ</summary>

[Статические методы промисов](https://learn.javascript.ru/promise-api).

</details>
